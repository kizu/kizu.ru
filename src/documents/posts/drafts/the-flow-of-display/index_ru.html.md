---

categories: fun

invisible: true

thanks_to:
    - "[Fev](http://taerin.deviantart.com/) за иллюстрацию"

---

# Отображение в потоке

![Как же собрать этот пазл?](/pictures/the-flow-of-display.jpg){:.b-figure width="756" height="382"}

В CSS есть множество нюансов. Иногда ты смотришь на код и думаешь: «Почему это вообще работает?!», и, чем опытнее ты становишься, тем реже это происходит. Но всё ещё иногда происходит.

Несколько дней назад мои коллеги нашли решение одной проблемы, но не смогли понять _почему_ оно работает, так что они показали его мне. Но и я не смог сходу разобраться. Только спустя несколько минут размышлений над кодом я понял в чём же заключается решение. Это оказалось тем, что я и так, оказывается, знал, но применённое в довольно необычном контексте.

Итак, у меня есть для вас небольшая задачка, решение для которой я приведу позже в этой статье: у вас есть два одинаковых HTML-элемента с практически одинаковым CSS. Оба элемента имеют `float:left`. Единственная вещь, которая различается — один из элементов имеет `display:inline-block`, а другой — `display:block`.

Вопрос: какие должны быть условия, чтобы в этом случае была разница в том, какое значение `display` (`inline-block` или `block`) к ним применяется?

В поисках такого условия можно добавлять любой CSS к этим элементам, любой HTML контекст, главное, чтобы всё это было одинаковым для обоих элементов, и, понятное дело, нельзя переопределять свойства `float` и `display`.

Советую подумать над этим вопросом (и поэкспериментировать с кодом) перед тем, как читать продолжение статьи, задачка того стоит.

## Ближе к ответу {#closer-to-the-answer}

Забавно, что это поведение можно использовать в реальном коде, а не только в качестве головоломки. Собственно, именно на реальном примере я с этим и столкнулся — как с одим из возможных решений довольно непростой задачки.

Исходная задача заключалась в том, чтобы в конце однострочного списка элементов расположить ещё один элемент так, чтобы он находился вплотную к остальным, при этом количество элементов до него варьировалось бы как в зависимости от и их ширины, так и от ширины родителя.

Единственное решение, которое мы в итоге нашли, работает при допущении, что ширина последнего элемента фиксированная — но для нашей задачи этого было достаточно.

Собственно, вот живой пример того, как работает описываемый в этой статье эффект, попробуйте поменять ширину браузера, чтобы увидеть что происходит с элементами списка.

[demo:the-flow-of-display1]

На самом деле тот эффект, что описывается в статье, можно заменить на чуть другой код, но это будет менее лаконично и интересно.

Небольшая последняя подсказка перед тем, как раскрыть карты: как можно отменить эффект свойства `float`, но оставить влияние свойства `display`, отличного от `none`?

Есть одно свойство, которое можно добавить, и которое сделает всё то, что нам нужно. Это `position`.

## Поток {#the-flow}

А если точнее, то `position:absolute` — если добавить его к нашим одинаковым элементам, то этим мы отменим поведение `float`. И многие разработчики думают, что абсолютное позиционирование полностью отменит и поведение `display`, но это не так.

В спецификациях CSS есть [одно интересное место](#todolink), которое можно перевести примерно так:

> whahahahahaha

Это значит, что если у элемента с `position:absolute` нет заданных свойств `top`, `right`, `bottom` и `left`, то этот элемент будет располагаться в том потоке, в котором он бы находился без применения позиционирования, и `display` в этом случае как раз влияет на то, какой же это будет поток.

Вот пример работы этого поведения:

[demo:the-flow-of-display2]

HTML обоих примеров одинаков, за исключением классов:

{:.language-html}
    <p>
      Hello
      <span class="a">A</span>
    </p>
    <p>
      Hello
      <span class="b">B</span>
    </p>

CSS для них такой:

{:.language-css}
    .a {
        float: left;
        display: inline-block;
        }
    .b {
        float: left;
        display: block;
        }
    .a,
    .b {
        position: absolute;
        }

Да, `float` тут не нужен, в этом случае он ничего не делает, но он и не будет отменять поведение `display`. И, тогда как оба элемента полностью одинаковы и имеют `position:absolute`, из-за значений `display` результат различается.

Чудесно! Подумайте о том, как одно свойство отменяет другое, но с добавлением третьего свойства первое свойство отменяется, а второе начинает действовать.

## Пример использования {#usage-example}

Теперь я попробую описать почему это поведение может быть полезно для примера со списком выше.

Напомню чего нам хотелось достичь — последний элемент должен всегда быть видимым и находиться в конце списка (вплотную к последнему элементу — поэтому тут не сработает обычный `float:right`), при том, что ширина списка динамически меняется: элементы «спрыгивают» за `overflow` когда им не хватает места.

Не самая простая задачка, причём я сам её сходу не смог быстро решить, но, по крайней мере, теперь я знаю как это сделать и почему это можно сделать именно так.

HTML для этого списка: 

{:.language-html}
    <ul class="just-some-items">
        <li class="just-some-item">One</li>
        <li class="just-some-item">Two</li>
        <li class="just-some-item">Three</li>
        <li class="just-some-item">Four</li>
        <li class="just-some-item">Five</li>
        <li class="just-some-item">Six</li>
        <li class="just-some-item">Seven</li>
        <li class="just-some-item">Eight</li>
        <li class="just-some-item">Nine</li>
        <li class="just-some-item">Ten</li>
        <li class="just-some-item">Eleven</li>
        <li class="just-some-item">…last</li>
    </ul>

А CSS таков (я оставлю часть презентационных стилей за рамками):

{:.language-css}
    .just-some-items {
        overflow: hidden;

        height: 2em;
        padding-right: 2.4em;
        margin: 0;
        }
    .just-some-item {
        float: left;

        margin-right: 0.5em;

        line-height: 2em;
        }
    .just-some-item:last-child {
        position: absolute;

        display: inline-block;

        width: 2.4em;
        }

Даже зная, что происходит внутри, когда я увидел этот код в первый раз, я не сразу в нём разобрался. А происходит тут следующее:

1. Все элементы списка флоатятся, что, в общем-то, обычно для подобных списков. Важно, что тут нельзя заменить `float` на `inline-block`.

2. Наличие флоатов выносит все элементы из обычного потока. Это значит, что если мы рядом положим какой-нибудь элемент в обычный поток, то все флоаты будут его обтекать слева.

3. Теперь важно чтобы «ширина» нашего последнего элемента была нулевой, и при этом он был бы в обычном потоке. В этом случае он как раз и будет всегда оставаться на первой «строчке» обычного потока, даже в тех случаях, когда флоаты занимают всё доступное место.

4. Тут в игру вступает `position:absolute`: он как раз и делает ровно то, что нам нужно — убирает `float` с этого элемента, возвращая его в обычный поток, и не даёт элементу занимать в своём потоке какое-либо место.

5. Но так как исходные элементы — `<li>`, то они изначально имеют блочное поведение, тогда как нам нужно, чтобы последний элемент находился в строчном контексте, иначе он не будет располагатсья на правильном месте. Тут мы и добавляем `display:inline-block` (и, на самом деле, достаточно добавить любое другое значение `display`, делающее его строчным). Теперь наш элемент «нулевой ширины» становится на правильное место в обычном потоке.

## Заключение

Эффект, описываемый в статье — именно то, за что я так люблю CSS. Различные свойства работают не только сами по себе, но и взаимодействуют друг с другом, порой в очень необычных, странных, неожиданных, но очень интересных комбинациях.

Чтобы полностью понять и погрузиться в CSS, важно и экспериментировать с кодом, и консультироваться со спецификациями в тех случаях, когда вы видите, что ваши эксперименты работают, но не знаете почему именно.

При таком подходе вы узнаете и запомните много нового, и потом, когда встретите похожую сложную задачу, сможете собрать решение из тех кусков паззла, что будут у вас на руках.
